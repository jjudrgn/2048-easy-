/************************************
input data
3
2 2 2
4 4 4
8 8 8

6
0 0 0 0 0 2
0 0 0 0 0 2
0 0 0 0 0 4
0 0 0 0 0 8
0 0 0 0 0 16
64 0 0 0 0 32

10
16 16 8 32 32 0 0 8 8 8
16 0 0 0 0 8 0 0 0 16
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0

3
8 512 0
128 0 64
512 2 2

3
0 64 512
0 256 256
0 0 0

3
0 16 0
16 512 0
512 256 1024

3

2 2 2
2 2 2 
2 2 2 

10

16 16 8 32 32 0 0 8 8 8
16 0 0 0 0 8 0 0 0 16
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0

7
2 2 2 2 2 2 2
2 0 2 2 2 2 2
2 0 2 2 2 2 2
2 0 2 2 2 2 2
2 2 2 0 2 2 2 
2 2 2 2 2 2 0
2 2 2 2 2 2 0

10
0 0 64 32 32 0 0 0 0 0
0 32 32 64 0 0 0 0 0 0
0 0 128 0 0 0 0 0 0 0 
64 64 128 0 0 0 0 0 0 0
0 0 64 32 32 0 0 0 0 0
0 32 32 64 0 0 0 0 0 0
0 0 128 0 0 0 0 0 0 0 
64 64 128 0 0 0 0 0 0 0
128 32 2 4 0 0 0 0 0 0
0 0 128 0 0 0 0 0 0 0

20
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024

10
0 0 0 0 0 32 8 64 8 16
0 0 0 0 0 0 0 16 8 16
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0

10

8 8 4 16 32 0 0 8 8 8
8 8 4 0 0 8 0 0 0 0
16 0 0 16 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 16
0 0 0 0 0 0 0 0 0 2

************************************/
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
using namespace std;

int n, maxN = 0;
int map[21][21];
int visited[21][21];

void dfs(int count) {
	if (count == 5) {
		for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) if (map[i][j] > maxN) maxN = map[i][j];
		return;
	}
	else {
		int temp[21][21];
		memcpy(temp, map, 21 * 21 * sizeof(int));
		for (int i = 0; i < 4; ++i) {
			memset(visited, 0, 21 * 21 * sizeof(int));
			switch (i) {
			case 0:
				for (int x = 0; x < n; ++x) for (int y = 0; y < n; ++y) {
					for (int ny = y; ny > 0; ny--) {
						if (map[ny][x] == 0) break;
						else {
							if (map[ny - 1][x] == 0) {
								map[ny - 1][x] = map[ny][x];
								map[ny][x] = 0;
								visited[ny - 1][x] = visited[ny][x];
								visited[ny][x] = 0;
							}
							else if (map[ny - 1][x] == map[ny][x] && visited[ny - 1][x] == 0 && visited[ny][x] == 0) {
								map[ny - 1][x] *= 2;
								map[ny][x] = 0;
								visited[ny - 1][x] = 1;
							}
						}
					}
				}
				break;
			case 1:
				for (int x = 0; x < n; ++x) for (int y = n - 1; y >= 0; --y) {
					for (int ny = y; ny < n - 1; ny++) {
						if (map[ny][x] == 0) break;
						else {
							if (map[ny + 1][x] == 0) {
								map[ny + 1][x] = map[ny][x];
								map[ny][x] = 0;
								visited[ny + 1][x] = visited[ny][x];
								visited[ny][x] = 0;
							}
							else if (map[ny + 1][x] == map[ny][x] && visited[ny + 1][x] == 0 && visited[ny][x] == 0) {
								map[ny + 1][x] *= 2;
								map[ny][x] = 0;
								visited[ny + 1][x] = 1;
							}
						}
					}
				}
				break;
			case 2:
				for (int y = 0; y < n; ++y) for (int x = 0; x < n; ++x) {
					for (int nx = x; nx > 0; nx--) {
						if (map[y][nx] == 0) break;
						else {
							if (map[y][nx - 1] == 0) {
								map[y][nx - 1] = map[y][nx];
								map[y][nx] = 0;
								visited[y][nx - 1] = visited[y][nx];
								visited[y][nx] = 0;
							}
							else if (map[y][nx - 1] == map[y][nx] && visited[y][nx - 1] == 0 && visited[y][nx] == 0) {
								map[y][nx - 1] *= 2;
								map[y][nx] = 0;
								visited[y][nx - 1] = 1;
							}
						}
					}
				}
				break;
			case 3:
				for (int y = 0; y < n; ++y) for (int x = n - 1; x >= 0; --x) {
					for (int nx = x; nx < n - 1; nx++) {
						if (map[y][nx] == 0) break;
						else {
							if (map[y][nx + 1] == 0) {
								map[y][nx + 1] = map[y][nx];
								map[y][nx] = 0;
								visited[y][nx + 1] = visited[y][nx];
								visited[y][nx] = 0;
							}
							else if (map[y][nx + 1] == map[y][nx] && visited[y][nx + 1] == 0 && visited[y][nx] == 0) {
								map[y][nx + 1] *= 2;
								map[y][nx] = 0;
								visited[y][nx + 1] = 1;
							}
						}
					}
				}
				break;
			default:
				printf("error\n");
			}
			dfs(count + 1);
			memcpy(map, temp, 21 * 21 * sizeof(int));
		}

	}
}

int main(void) {
	scanf("%d", &n);
	for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) scanf("%d", &map[i][j]);

	dfs(0);
	//printf("%d", maxN);
	bool true1 = true;
	while (true1) {
		cout << "--------------------" << endl;
		for (int i = 0; i < n; ++i) {
			for (int j = 0; j < n; ++j) {
				printf("%d ", map[i][j]);
			}
			printf("\n");
		}
		printf("\n");
		
		printf("What's the biggest number that can come out in five movement? \n");
		printf("8 : KB_UP\n2 : KB_DOWN\n4 : KB_LEFT\n6 : KB_RIGHT\n-1 : Answer\n");
		for (int i = 1; i <= 5; ++i) {
			int num;
			printf("%dmovent (KB_code): ",i);
			scanf("%d", &num);
			switch (num) {
			case 8:
				for (int x = 0; x < n; ++x) for (int y = 0; y < n; ++y) {
					for (int ny = y; ny > 0; ny--) {
						if (map[ny][x] == 0) break;
						else {
							if (map[ny - 1][x] == 0) {
								map[ny - 1][x] = map[ny][x];
								map[ny][x] = 0;
								visited[ny - 1][x] = visited[ny][x];
								visited[ny][x] = 0;
							}
							else if (map[ny - 1][x] == map[ny][x] && visited[ny - 1][x] == 0 && visited[ny][x] == 0) {
								map[ny - 1][x] *= 2;
								map[ny][x] = 0;
								visited[ny - 1][x] = 1;
							}
						}
					}
				}
				break;
			case 2:
				for (int x = 0; x < n; ++x) for (int y = n - 1; y >= 0; --y) {
					for (int ny = y; ny < n - 1; ny++) {
						if (map[ny][x] == 0) break;
						else {
							if (map[ny + 1][x] == 0) {
								map[ny + 1][x] = map[ny][x];
								map[ny][x] = 0;
								visited[ny + 1][x] = visited[ny][x];
								visited[ny][x] = 0;
							}
							else if (map[ny + 1][x] == map[ny][x] && visited[ny + 1][x] == 0 && visited[ny][x] == 0) {
								map[ny + 1][x] *= 2;
								map[ny][x] = 0;
								visited[ny + 1][x] = 1;
							}
						}
					}
				}
				break;
			case 4:
				for (int y = 0; y < n; ++y) for (int x = 0; x < n; ++x) {
					for (int nx = x; nx > 0; nx--) {
						if (map[y][nx] == 0) break;
						else {
							if (map[y][nx - 1] == 0) {
								map[y][nx - 1] = map[y][nx];
								map[y][nx] = 0;
								visited[y][nx - 1] = visited[y][nx];
								visited[y][nx] = 0;
							}
							else if (map[y][nx - 1] == map[y][nx] && visited[y][nx - 1] == 0 && visited[y][nx] == 0) {
								map[y][nx - 1] *= 2;
								map[y][nx] = 0;
								visited[y][nx - 1] = 1;
							}
						}
					}
				}
				break;
			case 6:
				for (int y = 0; y < n; ++y) for (int x = n - 1; x >= 0; --x) {
					for (int nx = x; nx < n - 1; nx++) {
						if (map[y][nx] == 0) break;
						else {
							if (map[y][nx + 1] == 0) {
								map[y][nx + 1] = map[y][nx];
								map[y][nx] = 0;
								visited[y][nx + 1] = visited[y][nx];
								visited[y][nx] = 0;
							}
							else if (map[y][nx + 1] == map[y][nx] && visited[y][nx + 1] == 0 && visited[y][nx] == 0) {
								map[y][nx + 1] *= 2;
								map[y][nx] = 0;
								visited[y][nx + 1] = 1;
							}
						}
					}
				}
				break;
			case -1:
				i = 6;
				break;
			default:
				printf("You sould input number in (8 : KB_UP, 2 : KB_DOWN, 4 : KB_LEFT, 6 : KB_RIGHT, -1 : Answer)\n");
				--i;
			}
			for (int i = 0; i < n; ++i) {
				for (int j = 0; j < n; ++j) {
					printf("%d ", map[i][j]);
				}
				printf("\n");
			}
			printf("\n");
		}
		
		printf("What's the biggest number? ");
		int NNum;
		scanf("%d", &NNum);
		if (NNum == maxN) {
			printf("Good job.\n");
			true1 = false;
		}
		else {
			printf("That's the wrong answer. Please try again...\m");
		}
	}
	system("pause");
}
